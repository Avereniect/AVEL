#ifndef $<HEADER_GUARD>
#define $<HEADER_GUARD>

namespace avel_tests {

    using namespace avel;

    //=========================================================================
    // $<mask_alias> tests
    //=========================================================================

    //=====================================================
    // Constructors
    //=====================================================

    TEST($<Mask_alias>, Construct_from_primitive) {
        $<mask_alias> mask{$<mask_alias>::primitive{}};

        EXPECT_FALSE(any(mask));
        EXPECT_FALSE(all(mask));
        EXPECT_TRUE(none(mask));
        EXPECT_EQ(count(mask), 0);
    }

    TEST($<Mask_alias>, Construct_from_bool) {
        $<mask_alias> mask0{false};
        EXPECT_FALSE(any(mask0));
        EXPECT_FALSE(all(mask0));
        EXPECT_TRUE(none(mask0));
        EXPECT_EQ(count(mask0), 0);

        $<mask_alias> mask1{true};
        EXPECT_TRUE(all(mask1));
        EXPECT_TRUE(any(mask1));
        EXPECT_FALSE(none(mask1));
        EXPECT_TRUE(count(mask1) == $<mask_alias>::width);
    }

    TEST($<Mask_alias>, Construct_from_array) {
        $<bool_array_alias> false_array{};
        std::fill_n(false_array.data(), $<mask_alias>::width, false);
        $<mask_alias> mask0{false_array};

        EXPECT_FALSE(any(mask0));
        EXPECT_FALSE(all(mask0));
        EXPECT_TRUE(none(mask0));
        EXPECT_EQ(count(mask0), 0);


        $<bool_array_alias> true_array{};
        std::fill_n(true_array.data(), $<mask_alias>::width, true);
        $<mask_alias> mask1{true_array};

        EXPECT_TRUE(any(mask1));
        EXPECT_TRUE(all(mask1));
        EXPECT_FALSE(none(mask1));
        EXPECT_TRUE(count(mask1) == $<mask_alias>::width);
    }

    TEST($<Mask_alias>, Construct_from_array_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<bool_array_alias>>();
            std::uint32_t cnt = std::count(inputs.begin(), inputs.end(), true);

            auto m = $<mask_alias>{inputs};

            EXPECT_EQ(cnt, count(m));
            EXPECT_EQ(cnt == $<mask_alias>::width, all(m));
            EXPECT_EQ(cnt != 0, any(m));
            EXPECT_EQ(cnt == 0, none(m));
        }
    }

    //=====================================================
    // Assignment
    //=====================================================

    TEST($<Mask_alias>, Assign_bool) {
        $<mask_alias> mask0{};
        mask0 = false;
        EXPECT_FALSE(any(mask0));
        EXPECT_FALSE(all(mask0));
        EXPECT_EQ(count(mask0), 0);

        $<mask_alias> mask1{};
        mask1 = true;
        EXPECT_TRUE(all(mask1));
        EXPECT_TRUE(any(mask1));
        EXPECT_TRUE(count(mask1) == $<mask_alias>::width);
    }

    //=====================================================
    // Comparison operators
    //=====================================================

    TEST($<Mask_alias>, Equality_comparison) {
        $<mask_alias> mask0{false};
        $<mask_alias> mask1{false};
        EXPECT_EQ(mask0, mask1);

        $<mask_alias> mask2{true};
        $<mask_alias> mask3{true};
        EXPECT_EQ(mask2, mask3);

        EXPECT_FALSE(mask0 == mask2);
        EXPECT_FALSE(mask3 == mask1);
    }

    TEST($<Mask_alias>, Equality_comparison_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<bool_array_alias>>();
            inputs1[0] = !inputs0[0];

            $<mask_alias> mask0{inputs0};
            $<mask_alias> mask1{inputs0};
            $<mask_alias> mask2{inputs1};

            EXPECT_TRUE(mask0 == mask1);
            EXPECT_FALSE(mask1 == mask2);
        }
    }

    TEST($<Mask_alias>, Inequality_comparison) {
        $<mask_alias> mask0{false};
        $<mask_alias> mask1{false};
        EXPECT_FALSE(mask0 != mask1);

        $<mask_alias> mask2{true};
        $<mask_alias> mask3{true};
        EXPECT_FALSE(mask2 != mask3);

        EXPECT_TRUE(mask0 != mask2);
        EXPECT_TRUE(mask3 != mask1);
    }

    TEST($<Mask_alias>, Inequality_comparison_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<bool_array_alias>>();
            inputs1[0] = !inputs0[0];

            $<mask_alias> mask0{inputs0};
            $<mask_alias> mask1{inputs1};
            $<mask_alias> mask2{inputs1};

            EXPECT_TRUE(mask0 != mask1);
            EXPECT_FALSE(mask1 != mask2);
        }
    }

    //=====================================================
    // Bitwise assignment
    //=====================================================

    TEST($<Mask_alias>, Bitwise_and_assignment_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<bool_array_alias>>();

            $<mask_alias> mask0{inputs0};
            $<mask_alias> mask1{inputs1};

            $<mask_alias> results = mask0;
            results &= mask1;

            $<bool_array_alias> expected;
            for (std::size_t j = 0; j < expected.size(); ++j) {
                expected[j] = inputs0[j] & inputs1[j];
            }
            $<mask_alias> expected_mask{expected};

            EXPECT_EQ(results, expected_mask);
        }
    }

    TEST($<Mask_alias>, Bitwise_or_assignment_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<bool_array_alias>>();

            $<mask_alias> mask0{inputs0};
            $<mask_alias> mask1{inputs1};

            $<mask_alias> results = mask0;
            results |= mask1;

            $<bool_array_alias> expected;
            for (std::size_t j = 0; j < expected.size(); ++j) {
                expected[j] = inputs0[j] | inputs1[j];
            }
            $<mask_alias> expected_mask{expected};

            EXPECT_EQ(results, expected_mask);
        }
    }

    TEST($<Mask_alias>, Bitwise_xor_assignment_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<bool_array_alias>>();

            $<mask_alias> mask0{inputs0};
            $<mask_alias> mask1{inputs1};

            $<mask_alias> results = mask0;
            results ^= mask1;

            $<bool_array_alias> expected;
            for (std::size_t j = 0; j < expected.size(); ++j) {
                expected[j] = inputs0[j] ^ inputs1[j];
            }
            $<mask_alias> expected_mask{expected};

            EXPECT_EQ(results, expected_mask);
        }
    }

    //=====================================================
    // Bitwise/logical operations
    //=====================================================

    TEST($<Mask_alias>, Logical_negation_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();

            $<mask_alias> mask0{inputs0};

            $<mask_alias> results = !mask0;

            $<bool_array_alias> expected;
            for (std::size_t j = 0; j < expected.size(); ++j) {
                expected[j] = !inputs0[j];
            }
            $<mask_alias> expected_mask{expected};

            EXPECT_EQ(results, expected_mask);
        }
    }

    TEST($<Mask_alias>, Bitwise_and_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<bool_array_alias>>();

            $<mask_alias> mask0{inputs0};
            $<mask_alias> mask1{inputs1};

            $<mask_alias> results = mask0 & mask1;

            $<bool_array_alias> expected;
            for (std::size_t j = 0; j < expected.size(); ++j) {
                expected[j] = inputs0[j] & inputs1[j];
            }
            $<mask_alias> expected_mask{expected};

            EXPECT_EQ(results, expected_mask);
        }
    }

    TEST($<Mask_alias>, Logical_and_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<bool_array_alias>>();

            $<mask_alias> mask0{inputs0};
            $<mask_alias> mask1{inputs1};

            $<mask_alias> results = mask0 && mask1;

            $<bool_array_alias> expected;
            for (std::size_t j = 0; j < expected.size(); ++j) {
                expected[j] = inputs0[j] && inputs1[j];
            }
            $<mask_alias> expected_mask{expected};

            EXPECT_EQ(results, expected_mask);
        }
    }

    TEST($<Mask_alias>, Bitwise_or_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<bool_array_alias>>();

            $<mask_alias> mask0{inputs0};
            $<mask_alias> mask1{inputs1};

            $<mask_alias> results = mask0 | mask1;

            $<bool_array_alias> expected;
            for (std::size_t j = 0; j < expected.size(); ++j) {
                expected[j] = inputs0[j] | inputs1[j];
            }
            $<mask_alias> expected_mask{expected};

            EXPECT_EQ(results, expected_mask);
        }
    }

    TEST($<Mask_alias>, Logical_or_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<bool_array_alias>>();

            $<mask_alias> mask0{inputs0};
            $<mask_alias> mask1{inputs1};

            $<mask_alias> results = mask0 || mask1;

            $<bool_array_alias> expected;
            for (std::size_t j = 0; j < expected.size(); ++j) {
                expected[j] = inputs0[j] || inputs1[j];
            }
            $<mask_alias> expected_mask{expected};

            EXPECT_EQ(results, expected_mask);
        }
    }

    TEST($<Mask_alias>, Bitwise_xor_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<bool_array_alias>>();

            $<mask_alias> mask0{inputs0};
            $<mask_alias> mask1{inputs1};

            $<mask_alias> results = mask0 ^ mask1;

            $<bool_array_alias> expected;
            for (std::size_t j = 0; j < expected.size(); ++j) {
                expected[j] = inputs0[j] ^ inputs1[j];
            }
            $<mask_alias> expected_mask{expected};

            EXPECT_EQ(results, expected_mask);
        }
    }

    //=========================================================================
    // $<Vector_alias> tests
    //=========================================================================

    //=====================================================
    // Constructors
    //=====================================================

    TEST($<Vector_alias>, Construct_vector_from_mask_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<bool_array_alias>>();

            $<mask_alias> m0{inputs};
            $<vector_alias> v0{m0};

            auto results = to_array(v0);
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                EXPECT_EQ(results[j], inputs[j]);
            }
        }
    }

    TEST($<Vector_alias>, Construct_from_scalar_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto x = random_val<$<vector_alias>::scalar>();
            $<vector_alias> results{x};

            $<array_alias> arr;
            std::fill_n(arr.data(), $<vector_alias>::width, x);
            $<vector_alias> expected{arr};

            EXPECT_TRUE(all(results == expected));
        }
    }

    TEST($<Vector_alias>, Construct_from_array_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto data = random_array<$<array_alias>>();

            $<vector_alias> v{data};

            auto results = to_array(v);

            for (std::size_t j = 0; j < data.size(); ++j) {
                EXPECT_EQ(data[j], results[j]);
            }
        }
    }

    //=====================================================
    // Assignment operators
    //=====================================================

    TEST($<Vector_alias>, Assign_primitive) {
        $<vector_alias>::primitive x{};
        $<vector_alias> v{0x0F};
        v = x;
        $<vector_alias> expected{0x00};

        EXPECT_TRUE(all(v == expected));
    }

    TEST($<Vector_alias>, Assign_scalar_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto scalar = random_val<$<vector_alias>::scalar>();
            $<vector_alias> v;
            v = scalar;

            auto results = to_array(v);
            for (std::size_t j = 0; j < results.size(); ++j) {
                EXPECT_EQ(results[j], scalar);
            }
        }
    }

    //=====================================================
    // Comparison operators
    //=====================================================

    TEST($<Vector_alias>, Equality_comparison) {
        $<mask_alias> mask0{false};
        $<mask_alias> mask1{false};
        EXPECT_EQ(mask0, mask1);

        $<mask_alias> mask2{true};
        $<mask_alias> mask3{true};
        EXPECT_EQ(mask2, mask3);
    }

    TEST($<Vector_alias>, Equality_comparison_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();
            inputs1[0] = ~inputs0[0];

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs0};
            $<vector_alias> v2{inputs1};

            EXPECT_TRUE(all(v0 == v1));
            EXPECT_FALSE(all(v1 == v2));
        }
    }

    TEST($<Vector_alias>, Inequality_comparison_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();
            inputs1[0] = ~inputs0[0];

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs0};
            $<vector_alias> v2{inputs1};

            EXPECT_FALSE(any(v0 != v1));
            EXPECT_TRUE(any(v1 != v2));
        }
    }

    TEST($<Vector_alias>, Less_than_comparison_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = (v0 < v1);

            $<bool_array_alias> expected{};
            for (std::size_t j = 0; j < expected.size(); ++j) {
                expected[j] = inputs0[j] < inputs1[j];
            }

            EXPECT_EQ(results, $<mask_alias>{expected});
        }
    }

    TEST($<Vector_alias>, Less_than_or_equal_comparison_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = (v0 <= v1);

            $<bool_array_alias> expected{};
            for (std::size_t j = 0; j < expected.size(); ++j) {
                expected[j] = inputs0[j] <= inputs1[j];
            }

            EXPECT_EQ(results, $<mask_alias>{expected});
        }
    }

    TEST($<Vector_alias>, Greater_than_comparison_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = (v0 > v1);

            $<bool_array_alias> expected{};
            for (std::size_t j = 0; j < expected.size(); ++j) {
                expected[j] = inputs0[j] > inputs1[j];
            }

            EXPECT_EQ(results, $<mask_alias>{expected});
        }
    }

    TEST($<Vector_alias>, Greater_than_or_equal_comparison_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = (v0 >= v1);

            $<bool_array_alias> expected{};
            for (std::size_t j = 0; j < expected.size(); ++j) {
                expected[j] = inputs0[j] >= inputs1[j];
            }

            EXPECT_EQ(results, $<mask_alias>{expected});
        }
    }

    //=====================================================
    // Unary arithmetic operators
    //=====================================================

    TEST($<Vector_alias>, Unary_plus) {
        auto inputs = random_array<$<array_alias>>();
        const $<vector_alias> u{inputs};
        $<vector_alias> v{+u};

        EXPECT_TRUE(all(u == v));
    }

    TEST($<Vector_alias>, Unary_minus) {
        auto inputs = random_array<$<array_alias>>();
        const $<vector_alias> input{inputs};

        auto results = -input;

        $<array_alias> expected{};
        for (std::size_t j = 0; j < expected.size(); ++j) {
            expected[j] = -inputs[j];
        }

        EXPECT_TRUE(all(results == $<vector_alias>{expected}));
    }

    //=====================================================
    // Arithmetic assignment operators
    //=====================================================

    TEST($<Vector_alias>, Plus_assignment_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = v0;
            results += v1;

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = inputs0[j] + inputs1[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Minus_assignment_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = v0;
            results -= v1;

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = inputs0[j] - inputs1[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Times_assignment_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = v0;
            results *= v1;

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = inputs0[j] * inputs1[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Div_assignment_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_denominator_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = v0;
            results /= v1;

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = inputs0[j] / inputs1[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Mod_assignment_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_denominator_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = v0;
            results %= v1;

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = inputs0[j] % inputs1[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    //=====================================================
    // Arithmetic operators
    //=====================================================

    TEST($<Vector_alias>, Addition_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = v0 + v1;

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = inputs0[j] + inputs1[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Subtraction_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = v0 - v1;

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = inputs0[j] - inputs1[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Multiplication_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = v0 * v1;

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = inputs0[j] * inputs1[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Division_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_denominator_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = v0 / v1;

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = inputs0[j] / inputs1[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Mod_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_denominator_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = v0 % v1;

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = inputs0[j] % inputs1[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    //=====================================================
    // Increment/Decrement operators
    //=====================================================

    TEST($<Vector_alias>, Pre_increment_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            $<vector_alias> input{inputs};
            ++input;

            auto results = input;
            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = ++inputs[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Post_increment_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            $<vector_alias> input{inputs};
            input++;

            auto results = input;
            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = ++inputs[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Pre_decrement_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            $<vector_alias> input{inputs};
            --input;

            auto results = input;
            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = --inputs[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Post_decrement_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            $<vector_alias> input{inputs};
            input--;

            auto results = input;
            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = --inputs[j];
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    //=====================================================
    // Conversion operators
    //=====================================================

    TEST($<Vector_alias>, Conversion_to_mask) {
        $<vector_alias> vec{0};

        auto a = vec.operator $<mask_alias>();
        $<mask_alias> b{false};

        EXPECT_TRUE(a == b);
    }

    TEST($<Vector_alias>, Conversion_to_mask_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            $<vector_alias> v{inputs};

            auto results = $<mask_alias>{v};

            $<bool_array_alias> expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = inputs[j];
            }

            EXPECT_TRUE(results == $<mask_alias>{expected});
        }
    }

    //=====================================================
    // Arrangement Operations
    //=====================================================

    TEST($<Vector_alias>, Extract_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();
            $<vector_alias> v{inputs};

            EXPECT_EQ(inputs[0x0], extract<0x0>(v));
            $<extract_tests>
        }
    }

    TEST($<Vector_alias>, Insert_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();
            $<vector_alias> v{random_val<$<vector_alias>::scalar>()};

            v = insert<0x0>(v, inputs[0x0]);
            $<insert_tests>

            EXPECT_TRUE(all(v == $<vector_alias>{inputs}));
        }
    }



    //=====================================================
    // General vector functions
    //=====================================================

    TEST($<Vector_alias>, Count_random) {
        auto predicate = [] ($<vector_alias>::scalar x) {
            return x != 0;
        };

        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();
            auto cnt = std::count_if(inputs.begin(), inputs.end(), predicate);

            $<vector_alias> v{inputs};

            auto results = count(v);

            EXPECT_EQ(cnt, results);
        }
    }

    TEST($<Vector_alias>, Any_edge_cases) {
        EXPECT_FALSE(any($<vector_alias>{0x00}));
        EXPECT_TRUE(any($<vector_alias>{0x01}));
    }

    TEST($<Vector_alias>, Any_random) {
        auto predicate = [] ($<vector_alias>::scalar x) {
            return x != 0;
        };

        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();
            auto cnt = std::count_if(inputs.begin(), inputs.end(), predicate);

            $<vector_alias> v{inputs};

            EXPECT_EQ(cnt != 0, any(v));
        }
    }

    TEST($<Vector_alias>, All_edge_cases) {
        EXPECT_FALSE(all($<vector_alias>{0x00}));
        EXPECT_TRUE(all($<vector_alias>{0x01}));
    }

    TEST($<Vector_alias>, All_random) {
        auto predicate = [] ($<vector_alias>::scalar x) {
            return x != 0;
        };

        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();
            auto cnt = std::count_if(inputs.begin(), inputs.end(), predicate);

            $<vector_alias> v{inputs};

            auto results = all(v);

            EXPECT_EQ(cnt == $<vector_alias>::width, results);
        }
    }

    TEST($<Vector_alias>, None_edge_cases) {
        EXPECT_TRUE(none($<vector_alias>{0x00}));
        EXPECT_FALSE(none($<vector_alias>{0x01}));
    }

    TEST($<Vector_alias>, None_random) {
        auto predicate = [] ($<vector_alias>::scalar x) {
            return x != 0;
        };

        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();
            auto cnt = std::count_if(inputs.begin(), inputs.end(), predicate);

            $<vector_alias> v{inputs};

            EXPECT_EQ(cnt == 0, none(v));
        }
    }

    TEST($<Vector_alias>, Keep_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<mask_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = keep(v0, v1);

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = keep(inputs0[j], inputs1[j]);
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Clear_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<mask_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = clear(v0, v1);

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = clear(inputs0[j], inputs1[j]);
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Blend_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();
            auto inputs2 = random_array<$<array_alias>>();

            $<mask_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};
            $<vector_alias> v2{inputs2};

            auto results = blend(v0, v1, v2);

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = blend(inputs0[j], inputs1[j], inputs2[j]);
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Max_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = max(v0, v1);

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = std::max(inputs0[j], inputs1[j]);
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Min_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = min(v0, v1);

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = std::min(inputs0[j], inputs1[j]);
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Minmax_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = minmax(v0, v1);

            $<array_alias> expected0{};
            $<array_alias> expected1{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                auto xy = minmax(inputs0[j], inputs1[j]);
                expected0[j] = xy[0];
                expected1[j] = xy[1];
            }

            EXPECT_TRUE(all(results[0] == $<vector_alias>{expected0}));
            EXPECT_TRUE(all(results[1] == $<vector_alias>{expected1}));
        }
    }

    TEST($<Vector_alias>, Clamp_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();
            auto inputs2 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};
            $<vector_alias> input2{inputs2};

            auto xy = minmax(v1, input2);

            auto results = clamp(v0, xy[0], xy[1]);

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                auto xy = minmax(inputs1[j], inputs2[j]);
                expected[j] = clamp(inputs0[j], xy[0], xy[1]);
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Average_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<vector_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = average(v0, v1);

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = average(inputs0[j], inputs1[j]);
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Negate_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs0 = random_array<$<bool_array_alias>>();
            auto inputs1 = random_array<$<array_alias>>();

            $<mask_alias> v0{inputs0};
            $<vector_alias> v1{inputs1};

            auto results = negate(v0, v1);

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs0.size(); ++j) {
                expected[j] = negate(inputs0[j], inputs1[j]);
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Abs_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            $<vector_alias> v{inputs};

            auto results = abs(v);

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = avel::abs(inputs[j]);
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    TEST($<Vector_alias>, Neg_abs_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            $<vector_alias> v{inputs};

            auto results = neg_abs(v);

            $<array_alias> expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = neg_abs(inputs[j]);
            }

            EXPECT_TRUE(all(results == $<vector_alias>{expected}));
        }
    }

    //=====================================================
    // Load/Store operations
    //=====================================================

    TEST($<Vector_alias>, Load_n_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            for (std::uint32_t j = 0; j < $<vector_alias>::width; ++j) {
                auto results = load<$<vector_alias>>(inputs.data(), j);

                auto loaded_data = to_array(results);
                for (std::uint32_t k = 0; k < $<vector_alias>::width; k++) {
                    if (k < j) {
                        EXPECT_EQ(inputs[k], loaded_data[k]);
                    } else {
                        EXPECT_EQ(0x0, loaded_data[k]);
                    }
                }
            }
        }
    }

    TEST($<Vector_alias>, Load_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            EXPECT_TRUE(all(load<$<vector_alias>, 0x00>(inputs.data()) == load<$<vector_alias>>(inputs.data(), 0x00)));
            $<load_tests>
        }
    }

    TEST($<Vector_alias>, Aligned_load_n_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            alignas(alignof($<vector_alias>)) auto inputs = random_array<$<array_alias>>();

            for (std::uint32_t j = 0; j < $<vector_alias>::width; ++j) {
                auto results = aligned_load<$<vector_alias>>(inputs.data(), j);

                auto loaded_data = to_array(results);
                for (std::uint32_t k = 0; k < $<vector_alias>::width; k++) {
                    if (k < j) {
                        EXPECT_EQ(inputs[k], loaded_data[k]);
                    } else {
                        EXPECT_EQ(0x0, loaded_data[k]);
                    }
                }
            }
        }
    }

    TEST($<Vector_alias>, Aligned_load_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            alignas(alignof($<vector_alias>)) auto inputs = random_array<$<array_alias>>();

            EXPECT_TRUE(all(aligned_load<$<vector_alias>, 0x00>(inputs.data()) == aligned_load<$<vector_alias>>(inputs.data(), 0x00)));
            $<aligned_load_tests>
        }
    }

    TEST($<Vector_alias>, Gather_n_random) {
        static constexpr std::size_t test_data_size = 16 * 1024;

        std::vector<$<vector_alias>::scalar> test_data{};
        test_data.resize(test_data_size);
        for (auto& x : test_data) {
            x = random_val<$<vector_alias>::scalar>();
        }

        for (std::size_t i = 0; i < iterations; ++i) {
            $<array_alias> index_array{};
            for (std::size_t j = 0; j < index_array.size(); ++j) {
                index_array[j] = random_val<$<unsigned_vector_alias>::scalar>() % test_data_size;
            }
            auto indices = load<$<vector_alias>>(index_array.data());

            for (std::size_t j = 0; j <= $<vector_alias>::width; ++j) {
                auto results = gather<$<vector_alias>>(test_data.data(), indices, j);

                auto loaded_data = to_array(results);
                for (std::size_t k = 0; k < $<vector_alias>::width; k++) {
                    if (k < j) {
                        EXPECT_EQ(test_data[index_array[k]], loaded_data[k]);
                    } else {
                        EXPECT_EQ(0x0, loaded_data[k]);
                    }
                }
            }
        }
    }

    TEST($<Vector_alias>, Gather_random) {
        static constexpr std::size_t test_data_size = 16 * 1024;

        std::vector<$<vector_alias>::scalar> test_data{};
        test_data.resize(test_data_size);
        for (auto& x : test_data) {
            x = random_val<$<vector_alias>::scalar>();
        }

        for (std::size_t i = 0; i < iterations; ++i) {
            $<array_alias> index_array{};
            for (std::size_t j = 0; j < $<vector_alias>::width; ++j) {
                index_array[j] = random_val<$<vector_alias>::scalar>() % test_data_size;
            }
            auto indices = load<$<vector_alias>>(index_array.data());

            EXPECT_TRUE(all(gather<$<vector_alias>, 0x00>(test_data.data(), indices) == gather<$<vector_alias>>(test_data.data(), indices, 0x00)));
            $<gather_tests>
        }
    }

    TEST($<Vector_alias>, Store_n) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            $<vector_alias> v{inputs};

            for (std::size_t j = 0; j < $<vector_alias>::width; ++j) {
                $<vector_alias>::scalar arr[$<vector_alias>::width]{};
                store(arr, v, j);

                for (std::size_t k = 0; k < inputs.size(); ++k) {
                    if (k < j) {
                        EXPECT_EQ(inputs[k], arr[k]);
                    } else {
                        EXPECT_EQ(0x00, arr[k]);
                    }
                }
            }
        }
    }

    TEST($<Vector_alias>, Store_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            $<vector_alias> v{inputs};

            $<vector_alias>::scalar arr[$<vector_alias>::width]{};

            store<0x00>(arr, v); EXPECT_TRUE(compare_stored_data(arr, v, 0x00));
            $<store_tests>
        }
    }

    TEST($<Vector_alias>, Aligned_store_n_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            $<vector_alias> v{inputs};

            for (std::size_t j = 0; j < $<vector_alias>::width; ++j) {
                alignas(alignof($<vector_alias>)) $<vector_alias>::scalar arr[$<vector_alias>::width]{};
                aligned_store(arr, v, j);

                for (std::size_t k = 0; k < inputs.size(); ++k) {
                    if (k < j) {
                        EXPECT_EQ(inputs[k], arr[k]);
                    } else {
                        EXPECT_EQ(0x00, arr[k]);
                    }
                }
            }
        }
    }

    TEST($<Vector_alias>, Aligned_store_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            $<vector_alias> v{inputs};

            alignas(alignof($<vector_alias>)) $<vector_alias>::scalar arr[$<vector_alias>::width]{};

            aligned_store<0x00>(arr, v); EXPECT_TRUE(compare_stored_data(arr, v, 0x00));
            $<aligned_store_tests>
        }
    }

    TEST($<Vector_alias>, Scatter_n_random) {
        static constexpr std::size_t test_data_size = 16 * 1024;
        static constexpr std::size_t block_size = test_data_size / $<vector_alias>::width;

        std::vector<$<vector_alias>::scalar> test_data{};
        test_data.resize(test_data_size);

        for (std::size_t i = 0; i < iterations; ++i) {
            auto input_array0 = random_array<$<array_alias>>();

            $<vector_alias> input0{input_array0};

            $<array_alias> index_array{};
            for (std::size_t j = 0; j < index_array.size(); ++j) {
                index_array[j] = (random_val<$<unsigned_vector_alias>::scalar>() % block_size) + (j * block_size);
            }

            $<vector_alias> indices{index_array};

            for (std::size_t j = 0; j <= $<unsigned_vector_alias>::width; ++j) {
                scatter(test_data.data(), input0, indices, j);

                for (std::size_t k = 0; k < input_array0.size(); ++k) {
                    if (k < j) {
                        EXPECT_EQ(input_array0[k], test_data[index_array[k]]);
                    }
                }
            }
        }
    }

    TEST($<Vector_alias>, Scatter_random) {
        static constexpr std::size_t test_data_size = 16 * 1024;
        static constexpr std::size_t block_size = test_data_size / $<vector_alias>::width;

        std::vector<$<vector_alias>::scalar> test_data{};
        test_data.resize(test_data_size);

        for (std::size_t i = 0; i < iterations; ++i) {
            auto input_array0 = random_array<$<array_alias>>();

            $<vector_alias> input0{input_array0};

            $<array_alias> index_array{};
            for (std::size_t j = 0; j < index_array.size(); ++j) {
                index_array[j] = (random_val<$<unsigned_vector_alias>::scalar>() % block_size) + (j * block_size);
            }

            $<vector_alias> indices{index_array};

            scatter<0x0>(test_data.data(), input0, indices); EXPECT_TRUE(compare_stored_data(test_data.data(), input0, indices, 0x00));
            $<scatter_tests>
        }
    }

    TEST($<Vector_alias>, To_array_random) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<$<array_alias>>();

            $<vector_alias> v{inputs};

            auto results = to_array(v);

            for (std::size_t j = 0; j < inputs.size(); ++j) {
                EXPECT_EQ(results[j], inputs[j]);
            }
        }
    }

    //=====================================================
    // Floating-point functions
    //=====================================================

    TEST($<Vector_alias>, fmax) {

    }

    TEST($<Vector_alias>, fmin) {

    }

    //=====================================================
    // Nearest Integer Operations
    //=====================================================

    TEST($<Vector_alias>, ceil) {

    }

    TEST($<Vector_alias>, floor) {

    }

    TEST($<Vector_alias>, trunc) {

    }

    TEST($<Vector_alias>, round) {

    }

    TEST($<Vector_alias>, nearbyint) {

    }

    TEST($<Vector_alias>, rint) {

    }

    //=====================================================
    // Floating-point Manipulation
    //=====================================================

    TEST($<Vector_alias>, frexp) {

    }

    TEST($<Vector_alias>, ldexp) {

    }

    TEST($<Vector_alias>, scalbn) {

    }

    TEST($<Vector_alias>, ilogb) {

    }

    TEST($<Vector_alias>, logb) {

    }

    TEST($<Vector_alias>, copysign) {

    }

    //=====================================================
    // Floating-point Classification
    //=====================================================

    TEST($<Vector_alias>, fpclassify) {

    }

    TEST($<Vector_alias>, isfinite) {

    }

    TEST($<Vector_alias>, isinf) {

    }

    TEST($<Vector_alias>, isnan) {

    }

    TEST($<Vector_alias>, isnormal) {

    }

    TEST($<Vector_alias>, signbit) {

    }

    //=====================================================
    // Floating-point Comparisons
    //=====================================================

    TEST($<Vector_alias>, isgreater) {

    }

    TEST($<Vector_alias>, isgreaterequal) {

    }

    TEST($<Vector_alias>, isless) {

    }

    TEST($<Vector_alias>, islessequal) {

    }

    TEST($<Vector_alias>, islessgreater) {

    }

    TEST($<Vector_alias>, isunordered) {

    }

}

#endif //$<HEADER_GUARD>
