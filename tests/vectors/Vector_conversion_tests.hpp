#ifndef AVEL_VECTOR_MASK_TESTS_HPP
#define AVEL_VECTOR_MASK_TESTS_HPP

namespace avel_tests {

    using namespace avel;

    TEST(Convert, vec1x8u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
#if defined(AVEL_SSE2) || defined(AVEL_NEON)
    TEST(Convert, vec1x8u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
#endif

#if defined(AVEL_AVX2)
    TEST(Convert, vec1x8u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
#endif

#if defined(AVEL_AVX512F)
    TEST(Convert, vec1x32u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
#endif

#if defined(AVEL_AVX512BW)
    TEST(Convert, vec1x8u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8u>();

            auto v0 = vec1x8u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x8i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x8i>();

            auto v0 = vec1x8i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16u>();

            auto v0 = vec1x16u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x16i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x16i>();

            auto v0 = vec1x16i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec1x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32u>();

            auto v0 = vec1x32u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32i>();

            auto v0 = vec1x32i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64u>();

            auto v0 = vec1x64u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64i>();

            auto v0 = vec1x64i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x32f_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x32f>();

            auto v0 = vec1x32f{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec1x64f_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr1x64f>();

            auto v0 = vec1x64f{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec1x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8u>();

            auto v0 = vec16x8u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x8i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x8i>();

            auto v0 = vec16x8i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16u>();

            auto v0 = vec8x16u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x16i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x16i>();

            auto v0 = vec8x16i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec8x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32u>();

            auto v0 = vec4x32u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32i>();

            auto v0 = vec4x32i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64u>();

            auto v0 = vec2x64u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64i>();

            auto v0 = vec2x64i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x32f_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x32f>();

            auto v0 = vec4x32f{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec2x64f_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr2x64f>();

            auto v0 = vec2x64f{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec2x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8u>();

            auto v0 = vec32x8u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x8i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x8i>();

            auto v0 = vec32x8i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16u>();

            auto v0 = vec16x16u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x16i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x16i>();

            auto v0 = vec16x16i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec16x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32u>();

            auto v0 = vec8x32u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32i>();

            auto v0 = vec8x32i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64u>();

            auto v0 = vec4x64u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64i>();

            auto v0 = vec4x64i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x32f_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x32f>();

            auto v0 = vec8x32f{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec4x64f_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr4x64f>();

            auto v0 = vec4x64f{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec4x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8u>();

            auto v0 = vec64x8u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec64x8u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec64x8i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr64x8i>();

            auto v0 = vec64x8i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec64x8i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16u_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16u>();

            auto v0 = vec32x16u{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x16u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec1x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec1x32u>(v0);

            arr1x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec1x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec1x32i>(v0);

            arr1x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec1x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec1x64u>(v0);

            arr1x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec1x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec1x64i>(v0);

            arr1x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec1x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec1x32f>(v0);

            arr1x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec1x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec1x64f>(v0);

            arr1x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec4x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec4x32u>(v0);

            arr4x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec4x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec4x32i>(v0);

            arr4x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec2x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec2x64u>(v0);

            arr2x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec2x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec2x64i>(v0);

            arr2x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec4x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec4x32f>(v0);

            arr4x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec2x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec2x64f>(v0);

            arr2x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec8x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec8x32u>(v0);

            arr8x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec8x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec8x32i>(v0);

            arr8x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec4x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec4x64u>(v0);

            arr4x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec4x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec4x64i>(v0);

            arr4x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec8x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec8x32f>(v0);

            arr8x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec4x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec4x64f>(v0);

            arr4x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec16x32u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec16x32u>(v0);

            arr16x32u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec16x32i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec16x32i>(v0);

            arr16x32i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int32_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec8x64u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec8x64u>(v0);

            arr8x64u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec8x64i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec8x64i>(v0);

            arr8x64i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int64_t>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec16x32f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec16x32f>(v0);

            arr16x32f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<float>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec32x16i_to_vec8x64f) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr32x16i>();

            auto v0 = vec32x16i{inputs};
            auto results = avel::convert<vec8x64f>(v0);

            arr8x64f expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<double>(inputs[j]);
            }
            
            std::size_t w = vec32x16i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32u>();

            auto v0 = vec16x32u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32i>();

            auto v0 = vec16x32i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64u_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64u>();

            auto v0 = vec8x64u{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64u::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64i_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64i>();

            auto v0 = vec8x64i{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64i::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec16x32f_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr16x32f>();

            auto v0 = vec16x32f{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec16x32f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec1x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec1x8u>(v0);

            arr1x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec1x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec1x8i>(v0);

            arr1x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec1x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec1x16u>(v0);

            arr1x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec1x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec1x16i>(v0);

            arr1x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec16x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec16x8u>(v0);

            arr16x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec16x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec16x8i>(v0);

            arr16x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec8x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec8x16u>(v0);

            arr8x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec8x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec8x16i>(v0);

            arr8x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec32x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec32x8u>(v0);

            arr32x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec32x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec32x8i>(v0);

            arr32x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec16x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec16x16u>(v0);

            arr16x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec16x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec16x16i>(v0);

            arr16x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec64x8u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec64x8u>(v0);

            arr64x8u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec64x8i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec64x8i>(v0);

            arr64x8i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int8_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec32x16u) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec32x16u>(v0);

            arr32x16u expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::uint16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
    TEST(Convert, vec8x64f_to_vec32x16i) {
        for (std::size_t i = 0; i < iterations; ++i) {
            auto inputs = random_array<arr8x64f>();

            auto v0 = vec8x64f{inputs};
            auto results = avel::convert<vec32x16i>(v0);

            arr32x16i expected{};
            for (std::size_t j = 0; j < inputs.size(); ++j) {
                expected[j] = static_cast<std::int16_t>(inputs[j]);
            }
            
            std::size_t w = vec8x64f::width / results.size();
            for (std::size_t j = 0; j < results.size(); ++j) {
                auto observed = avel::to_array(results[j]);

                for (std::size_t k = 0; k < observed.size(); ++k) {
                    EXPECT_TRUE(expected[j * w + k] == observed[k]);
                }
            }
        }
    }
    
#endif

}

#endif //AVEL_VECTOR_MASK_TESTS_HPP
